为什么用泛型？
从集合中拿出时要强转，但强转未必成功，因为不知道集合中的元素是什么类型，此时需要泛型。
泛型是从jdk1.5开始出现的安全新特性。这样一来，运行时错误被转移为编译时错误，且避免了强制转换的繁琐。
使用泛型后，迭代器也需要泛型。

擦除与补偿
泛型技术是给编译时期使用的，以保证代码的安全。
然而生成class文件时是没有泛型信息的，这叫擦除。这是为了兼容类加载器。
所以集合中的类还是object。而由于已经保证了代码的安全，所以不必强转。
编写补偿程序：利用getclass获取类名。

TreeSet：implement Comparable也要有个<T>，而这个比较器的T应该是TreeSetT的父类或本类。

若一个类有一个Object属性的字段，setObject可以传入任何类去给Object字段赋值，此时getObject只能读出Object类，此时若强行转换为与原装入类不一致的类，即为出错。
此时用泛型定义类。
若一个泛型类表明泛型代号T，而一个方法希望接受一切参数，那么用   权限 <w> 返回值 函数名（<w> a）的格式
静态方法不能用泛型，因为泛型只在new时被定义。此时像上一行一样将泛型定义在方法上。
可以在接口上定义一个泛型，在继承该接口的类上声明泛型一致，当new类时才确定具体的类型。

泛型的上界：泛型的通配符：？未知类型 。？用于泛型类型不明的参数中，T用于泛型定义和类型不明的参数中（与？不同是所有的T必须一样，而且？对象不能进行操作），具体类名用于被继承、实现和函数中使用。
当AB类都继承c类，若参数中的 集合的 泛型类型不定，则可以写泛型为<？ extends c>（collection<person>=new collection<student>()报错，因为也有可能装入worker。iterator也要改变泛型。取出的对象都按父类看待
若addAll函数内外两个泛型不匹配，报错——这是编译时出错的。但若两个泛型都没写，则默认object不会编译时报错，运行时不安全。而只需要两个泛型一样太死板，所以要有上界的存在。取出的元素都按上限类算。
泛型的下界：用得不多。函数参数泛型<？super A>，其他同上。用的情况：AB继承C，TreeSet不一定是AB，此时写一个泛型C的comparator。
比较是一种“取出对象”，用下界；添加add时，用上界：因为取出时算作父类类型，即使放入了不同的子类也不会出问题。
contains跟equals一样，参数类型不重要，所以用？泛型。当所有的方法都用object方法，一般可以用？泛型做参数
